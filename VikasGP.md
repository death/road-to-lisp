# Vikas G P

## When did you first try Lisp seriously, and which Lisp family member was it?

My first serious encounter with Lisp was sometime during June-July
2003, when I discovered Paul Graham's website through a story on
Slashdot. So I installed CMUCL, got a copy of Winston and Horn, read a
bit, and wrote a small program. In September or so I discovered
"Structure and Interpretation of Computer Programs" and really started
learning Scheme seriously (and still am).

## What led you to try Lisp?

I had read somewhat mystic references to Lisp such as that by Eric
Raymond: "Lisp is worth learning for the profound enlightening
experience you'll have when you finally get it". Somehow, I feel like
I always knew Lisp to be this incredibly cool thing I had to learn
someday.

## Where did your road originate?

Since I was just a student at the time I discovered Lisp (and still
am), there was much of a question of switching from another
language. I was just looking to learn many languages. But I had
discovered Python just before that and was slowly beginning to realize
that maybe C wasn't the answer to everything. But more than everything
else, it was the "coolness" of Lisp that made me start learning it,
regardless of its real world viability or anything.

## How far have you gotten in your study of Lisp?

Not really far, I guess. For one thing, I'm comfortable with
parentheses and Emacs :). I understand most of the basic stuff like
list manipulations, let, lambda, etc. I also think I understand
lexical scope and closures pretty well.  The things I don't understand
yet are macros in Common Lisp, continuations in Scheme and
define-syntax, etc. in Scheme. Oh, and dynamic scope too.

## What do you think of Lisp so far?

I think Lisp is incredibly cool, and already I've started noticing the
effects of learning Lisp on my programming style. I write better
programs, and may I say more elegant programs, in C or any other
language. Writing an algorithm in Scheme feels so natural, as if I'm
thinking in Scheme. Lisp serves as a reference point against which I
can compare and rate other languages. It also serves as a very
flexible language to experiment various programming paradigms.
