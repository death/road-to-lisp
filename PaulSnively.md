# Paul Snively

## When did you first try Lisp (meaning here and throughout the survey "any member of the Lisp family") seriously, and which Lisp family member was it?

It depends a bit upon what you mean by "try." As a high school student
in my hometown in the early 1980s, and the son of two educators, I
occasionally had the opportunity to visit the nearby university. Upon
one such trip, I stumbled across the SRI edition of "The Little
LISPer." I was immediately enchanted both by the style and what I
intuited as the power of the ideas: it was quite the contrast to Tiny
Pascal on my TRS-80 at home! Thankfully, Scheme is a sufficiently
small, simple dialect that a non-toy implementation would run on my
trusty Model I.

It's worth pointing out that my hometown was Columbus, Indiana, and
that the nearby university was Indiana University, a **major**
Scheme school, and home to this day of Dan Friedman, co-author of "The
Little Schemer;" Douglas Hofstadter, author of "GÃ¶del, Escher, Bach;"
and Raymond Smullyan, author of innumerable charming logic puzzle
story books, among other things.

## What led you to try Lisp?

The emphasis in "The Little LISPer" on solving problems in terms of
simpler versions of themselves, formally known as "recursion." IIRC,
Tiny Pascal didn't support recursion, so it was a new concept to me at
the time. As I delved more deeply into it (especially once I ended up
at IU and got to talk to Dr. Friedman and Dr. Hofstadter regularly), I
got the best possible kind of indoctrination into the real power
behind the deceptively-simple language. This was not that long after
Dr. Friedman had begun making his argument that cons shouldn't
evaluate its arguments, so I learned a lot in those days about lazy
evaluation, infinitely-long lists, etc. Stuff that you flat couldn't
do (and still can't modulo libraries like FC++, Boost Lambda, and/or
Phoenix) in any of the mainstream languages.

BTW, I find it fascinating that FC++, Boost Lambda, and Phoenix all do
exist for C++.

## If you were trying Lisp out of unhappiness with another language, what was that other language and what did you not like about it, or what were you hoping to find different in Lisp?

Scheme is vastly simpler than most languages while simultaneously
being vastly more expressively powerful. Common Lisp is vastly more
complex than most languages while simultaneously being as expressively
powerful as Scheme.

## How far have you gotten in your study of Lisp? (I know, that is hard to measure)

Not that hard. I consider myself an expert Common Lisp or Scheme
programmer. For essentially the entirety of my post-TRS-80 years,
which are greater in number than I like to think about, all of my
recreational programming has been in either Common Lisp or
Scheme. When people ask me how to learn to be a programmer, I point
them to "The Little Schemer" or "SICP," depending upon my assessment
of their likely ability, and I suggest they download DrScheme. When I
was in MacDTS at Apple (1989-1991), I was the only MacDTS engineer
supporting Apple's Macintosh Common Lisp, which they had bought from
Coral Software and which was later sold again to Digitool and
continues to be available, and one of the best Common Lisp
implementations for any platform, ever. I had the great pleasure of
making the acquaintance of folks like Bill St. Clair, Andrew Shalit,
and Mikel Evins. I also had the distinct honor of being a technical
reviewer for Peter Norvig's "Paradigms of Artificial Intelligence
Programming: Case Studies in Common Lisp;" my name is generously
included in the acknowledgments.

## What do you think of Lisp so far?

Joel Moses claimed that, by way of contrast to the elegant crystalline
purity of APL, Lisp was a ball of mud: you could add anything you
wanted to it and it would still be a ball of mud. My own thinking is
that Lisp is the cockroach of programming languages: it'll be the only
one left after the apocalypse. "Not bad for a dead language."
