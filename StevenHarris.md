# Steven Harris

## When did you first try Lisp seriously, and which Lisp family member was it?

Early 1998, with XEmacs Lisp. More recently, I have been studying and
using Common Lisp by way of CLISP since early 2000.

## What led you to try Lisp?

I needed to use it to customize XEmacs. At first, I wondered why one
was forced to type an incessant sequence of `(setq this-variable
that-value)` expressions just to fix up the editor. "What a strange
configuration file format," I thought. And then I read more, sought
more examples, and talked to my co-workers, and they grinned as the
light slowly came on: This is no mere configuration file; this is a
program in a complete programming language. From that point on, I no
longer considered XEmacs to be a program I use, but rather as a kit
from which I build a constantly evolving set of programs.

I came to Common Lisp after reading various posts on comp.lang.lisp
assailing (X)Emacs Lisp as limited and inferior to other dialects. I
had understood that Lisp was a category of similar dialects, each
trapped within their small worlds, such as (X)Emacs Lisp and
AutoLISP. That frustrated me. The productivity and limpid enjoyment in
Lisp were obvious, but I regretted not being able to use it to create
a "real stand-alone" program. Common Lisp turned out to be answer.

## Where did your road originate?

I came to Lisp from C++, Perl, and a little Python. I like those
languages just fine, but none of them rise above their shortcomings so
clearly as Common Lisp.

Perl is problematic for its lack of consistency and clarity. I have
written some pretty brilliant Perl programs, or at least I think I
have, but I can't read them anymore. If one leaves Perl for a while,
coming back to it is always an annoying relearning process. It doesn't
feel like a language that will last forever. Maybe that's fine, as
most of the programs I wrote in Perl were more or less intentionally
temporary, but I'd rather **choose** to throw away my drawings on
archival paper than see them disintegrate involuntarily on cocktail
napkins.

C++ is problematic for its arcane and limited support for higher-level
abstractions. The recent advances in template metaprogramming are
amazing but embarrassing; it shouldn't take that kind of abuse to
solve problems with elegance. I am slowly coming to see that my
approach to programming is changing, and C++ is no longer the best
fit. C++ can be twisted in strange ways to do wonderful things, but I
am not sufficiently interested in keeping up with the latest baroque
hacks to sacrifice that much attention and brain space for little
gain. I'd rather move on to a language with more direct support for
the rising level at which I wish to think and create.

## How far have you gotten in your study of Lisp?

I can write small applications, but stumble over large program
organization. My use of the language is narrow; I have yet to employ
the condition system, to push CLOS beyond simple types, to make direct
use of the reader, or to explore the optimization process.

Familiarity with the larger language will come. None of it looks too
daunting to learn. I have been guided thus far more by necessity than
interest; when I need more out of Lisp, I will learn more of it.

## What do you think of Lisp so far?

I regret not having come to it sooner, and I cannot foresee growing
out of it. Lisp is like the best kind of assistant: powerful,
enabling, and invisible. The upper limits of complexity lie then in my
own mind, not with the language.
