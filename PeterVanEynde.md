# Peter Van Eynde

## When did you first try Lisp (meaning here and throughout the survey "any member of the Lisp family") seriously, and which Lisp family member was it?

I started using
[clisp](https://web.archive.org/web/20110924165845/http://wiki.alu.org/clisp)
and
[cmucl](https://web.archive.org/web/20110924165845/http://wiki.alu.org/cmucl)
seriously in university. I wanted to apply the power of Common Lisp to
physics problems. It worked rather well, of course
[FORTRAN](https://web.archive.org/web/20110924165845/http://wiki.alu.org/FORTRAN)
can be optimized better, but the higher level abstractions gave me a
advantage. The other students or professors where looking at C++ or
Java as an alternative to F77. Some went back to
[FORTRAN](https://web.archive.org/web/20110924165845/http://wiki.alu.org/FORTRAN)
2000 I've heard.

## What led you to try Lisp?

Lambda caculus, macros, emacs and the Hackers dictionary.  Using
Mathematica already convinced me that Lambda caculus was an ideal tool
for physics.

## If you were trying Lisp out of unhappiness with another language, what was that other language and what did you not like about it, or what were you hoping to find different in Lisp?

I found
[FORTRAN](https://web.archive.org/web/20110924165845/http://wiki.alu.org/FORTRAN)
77 to primitive,
[FORTRAN](https://web.archive.org/web/20110924165845/http://wiki.alu.org/FORTRAN)
90 to immature (at that time), C++ a plain horror of possesiveness,
Java just wrongly OO'ed, Smalltalk useless without a GUI, Mathematica
just too slow.

## How far have you gotten in your study of Lisp? (I know, that is hard to measure)

Pretty far, but still I find hidden treasure almost every time I
managed to write CL code.

## What do you think of Lisp so far?

The final language. Other languages might be more adapted to small
quickly solved problems (I am a
[AWK](https://web.archive.org/web/20110924165845/http://wiki.alu.org/AWK)
fan too) but if the problem becomes too big or you don't know the
problem yet, then the only rational choice is Common Lisp. No other
language lets you explore the problem so fast and most of the time,
buy the time you've described the problem you've solved it. The
solution might be slow, hacked together and brittle, but it can be
made fast, well designed and stable in a incremental way, having a
working solution almost all the time and changing only those parts
that need work. I know of no other language (except Common Lisp
lookalikes) that offer that much support for this kind of work.
